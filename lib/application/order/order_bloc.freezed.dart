// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'order_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$OrderEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initGeolocation,
    required TResult Function() loadOrders,
    required TResult Function(OrderStatus status) statusChanged,
    required TResult Function(Operator serviceOperator) operatorChanged,
    required TResult Function() operatorCleared,
    required TResult Function(int orderId) startOrder,
    required TResult Function(int orderId) endOrder,
    required TResult Function(int orderId) cancelOrder,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initGeolocation,
    TResult? Function()? loadOrders,
    TResult? Function(OrderStatus status)? statusChanged,
    TResult? Function(Operator serviceOperator)? operatorChanged,
    TResult? Function()? operatorCleared,
    TResult? Function(int orderId)? startOrder,
    TResult? Function(int orderId)? endOrder,
    TResult? Function(int orderId)? cancelOrder,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initGeolocation,
    TResult Function()? loadOrders,
    TResult Function(OrderStatus status)? statusChanged,
    TResult Function(Operator serviceOperator)? operatorChanged,
    TResult Function()? operatorCleared,
    TResult Function(int orderId)? startOrder,
    TResult Function(int orderId)? endOrder,
    TResult Function(int orderId)? cancelOrder,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitGeolocation value) initGeolocation,
    required TResult Function(LoadOrders value) loadOrders,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(OperatorChanged value) operatorChanged,
    required TResult Function(OperatorCleared value) operatorCleared,
    required TResult Function(StartOrder value) startOrder,
    required TResult Function(EndOrder value) endOrder,
    required TResult Function(CancelOrder value) cancelOrder,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitGeolocation value)? initGeolocation,
    TResult? Function(LoadOrders value)? loadOrders,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(OperatorChanged value)? operatorChanged,
    TResult? Function(OperatorCleared value)? operatorCleared,
    TResult? Function(StartOrder value)? startOrder,
    TResult? Function(EndOrder value)? endOrder,
    TResult? Function(CancelOrder value)? cancelOrder,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitGeolocation value)? initGeolocation,
    TResult Function(LoadOrders value)? loadOrders,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(OperatorChanged value)? operatorChanged,
    TResult Function(OperatorCleared value)? operatorCleared,
    TResult Function(StartOrder value)? startOrder,
    TResult Function(EndOrder value)? endOrder,
    TResult Function(CancelOrder value)? cancelOrder,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrderEventCopyWith<$Res> {
  factory $OrderEventCopyWith(
          OrderEvent value, $Res Function(OrderEvent) then) =
      _$OrderEventCopyWithImpl<$Res, OrderEvent>;
}

/// @nodoc
class _$OrderEventCopyWithImpl<$Res, $Val extends OrderEvent>
    implements $OrderEventCopyWith<$Res> {
  _$OrderEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitGeolocationCopyWith<$Res> {
  factory _$$InitGeolocationCopyWith(
          _$InitGeolocation value, $Res Function(_$InitGeolocation) then) =
      __$$InitGeolocationCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitGeolocationCopyWithImpl<$Res>
    extends _$OrderEventCopyWithImpl<$Res, _$InitGeolocation>
    implements _$$InitGeolocationCopyWith<$Res> {
  __$$InitGeolocationCopyWithImpl(
      _$InitGeolocation _value, $Res Function(_$InitGeolocation) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitGeolocation implements InitGeolocation {
  const _$InitGeolocation();

  @override
  String toString() {
    return 'OrderEvent.initGeolocation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitGeolocation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initGeolocation,
    required TResult Function() loadOrders,
    required TResult Function(OrderStatus status) statusChanged,
    required TResult Function(Operator serviceOperator) operatorChanged,
    required TResult Function() operatorCleared,
    required TResult Function(int orderId) startOrder,
    required TResult Function(int orderId) endOrder,
    required TResult Function(int orderId) cancelOrder,
  }) {
    return initGeolocation();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initGeolocation,
    TResult? Function()? loadOrders,
    TResult? Function(OrderStatus status)? statusChanged,
    TResult? Function(Operator serviceOperator)? operatorChanged,
    TResult? Function()? operatorCleared,
    TResult? Function(int orderId)? startOrder,
    TResult? Function(int orderId)? endOrder,
    TResult? Function(int orderId)? cancelOrder,
  }) {
    return initGeolocation?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initGeolocation,
    TResult Function()? loadOrders,
    TResult Function(OrderStatus status)? statusChanged,
    TResult Function(Operator serviceOperator)? operatorChanged,
    TResult Function()? operatorCleared,
    TResult Function(int orderId)? startOrder,
    TResult Function(int orderId)? endOrder,
    TResult Function(int orderId)? cancelOrder,
    required TResult orElse(),
  }) {
    if (initGeolocation != null) {
      return initGeolocation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitGeolocation value) initGeolocation,
    required TResult Function(LoadOrders value) loadOrders,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(OperatorChanged value) operatorChanged,
    required TResult Function(OperatorCleared value) operatorCleared,
    required TResult Function(StartOrder value) startOrder,
    required TResult Function(EndOrder value) endOrder,
    required TResult Function(CancelOrder value) cancelOrder,
  }) {
    return initGeolocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitGeolocation value)? initGeolocation,
    TResult? Function(LoadOrders value)? loadOrders,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(OperatorChanged value)? operatorChanged,
    TResult? Function(OperatorCleared value)? operatorCleared,
    TResult? Function(StartOrder value)? startOrder,
    TResult? Function(EndOrder value)? endOrder,
    TResult? Function(CancelOrder value)? cancelOrder,
  }) {
    return initGeolocation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitGeolocation value)? initGeolocation,
    TResult Function(LoadOrders value)? loadOrders,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(OperatorChanged value)? operatorChanged,
    TResult Function(OperatorCleared value)? operatorCleared,
    TResult Function(StartOrder value)? startOrder,
    TResult Function(EndOrder value)? endOrder,
    TResult Function(CancelOrder value)? cancelOrder,
    required TResult orElse(),
  }) {
    if (initGeolocation != null) {
      return initGeolocation(this);
    }
    return orElse();
  }
}

abstract class InitGeolocation implements OrderEvent {
  const factory InitGeolocation() = _$InitGeolocation;
}

/// @nodoc
abstract class _$$LoadOrdersCopyWith<$Res> {
  factory _$$LoadOrdersCopyWith(
          _$LoadOrders value, $Res Function(_$LoadOrders) then) =
      __$$LoadOrdersCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadOrdersCopyWithImpl<$Res>
    extends _$OrderEventCopyWithImpl<$Res, _$LoadOrders>
    implements _$$LoadOrdersCopyWith<$Res> {
  __$$LoadOrdersCopyWithImpl(
      _$LoadOrders _value, $Res Function(_$LoadOrders) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadOrders implements LoadOrders {
  const _$LoadOrders();

  @override
  String toString() {
    return 'OrderEvent.loadOrders()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadOrders);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initGeolocation,
    required TResult Function() loadOrders,
    required TResult Function(OrderStatus status) statusChanged,
    required TResult Function(Operator serviceOperator) operatorChanged,
    required TResult Function() operatorCleared,
    required TResult Function(int orderId) startOrder,
    required TResult Function(int orderId) endOrder,
    required TResult Function(int orderId) cancelOrder,
  }) {
    return loadOrders();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initGeolocation,
    TResult? Function()? loadOrders,
    TResult? Function(OrderStatus status)? statusChanged,
    TResult? Function(Operator serviceOperator)? operatorChanged,
    TResult? Function()? operatorCleared,
    TResult? Function(int orderId)? startOrder,
    TResult? Function(int orderId)? endOrder,
    TResult? Function(int orderId)? cancelOrder,
  }) {
    return loadOrders?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initGeolocation,
    TResult Function()? loadOrders,
    TResult Function(OrderStatus status)? statusChanged,
    TResult Function(Operator serviceOperator)? operatorChanged,
    TResult Function()? operatorCleared,
    TResult Function(int orderId)? startOrder,
    TResult Function(int orderId)? endOrder,
    TResult Function(int orderId)? cancelOrder,
    required TResult orElse(),
  }) {
    if (loadOrders != null) {
      return loadOrders();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitGeolocation value) initGeolocation,
    required TResult Function(LoadOrders value) loadOrders,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(OperatorChanged value) operatorChanged,
    required TResult Function(OperatorCleared value) operatorCleared,
    required TResult Function(StartOrder value) startOrder,
    required TResult Function(EndOrder value) endOrder,
    required TResult Function(CancelOrder value) cancelOrder,
  }) {
    return loadOrders(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitGeolocation value)? initGeolocation,
    TResult? Function(LoadOrders value)? loadOrders,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(OperatorChanged value)? operatorChanged,
    TResult? Function(OperatorCleared value)? operatorCleared,
    TResult? Function(StartOrder value)? startOrder,
    TResult? Function(EndOrder value)? endOrder,
    TResult? Function(CancelOrder value)? cancelOrder,
  }) {
    return loadOrders?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitGeolocation value)? initGeolocation,
    TResult Function(LoadOrders value)? loadOrders,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(OperatorChanged value)? operatorChanged,
    TResult Function(OperatorCleared value)? operatorCleared,
    TResult Function(StartOrder value)? startOrder,
    TResult Function(EndOrder value)? endOrder,
    TResult Function(CancelOrder value)? cancelOrder,
    required TResult orElse(),
  }) {
    if (loadOrders != null) {
      return loadOrders(this);
    }
    return orElse();
  }
}

abstract class LoadOrders implements OrderEvent {
  const factory LoadOrders() = _$LoadOrders;
}

/// @nodoc
abstract class _$$StatusChangedCopyWith<$Res> {
  factory _$$StatusChangedCopyWith(
          _$StatusChanged value, $Res Function(_$StatusChanged) then) =
      __$$StatusChangedCopyWithImpl<$Res>;
  @useResult
  $Res call({OrderStatus status});
}

/// @nodoc
class __$$StatusChangedCopyWithImpl<$Res>
    extends _$OrderEventCopyWithImpl<$Res, _$StatusChanged>
    implements _$$StatusChangedCopyWith<$Res> {
  __$$StatusChangedCopyWithImpl(
      _$StatusChanged _value, $Res Function(_$StatusChanged) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
  }) {
    return _then(_$StatusChanged(
      null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as OrderStatus,
    ));
  }
}

/// @nodoc

class _$StatusChanged implements StatusChanged {
  const _$StatusChanged(this.status);

  @override
  final OrderStatus status;

  @override
  String toString() {
    return 'OrderEvent.statusChanged(status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StatusChanged &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(runtimeType, status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StatusChangedCopyWith<_$StatusChanged> get copyWith =>
      __$$StatusChangedCopyWithImpl<_$StatusChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initGeolocation,
    required TResult Function() loadOrders,
    required TResult Function(OrderStatus status) statusChanged,
    required TResult Function(Operator serviceOperator) operatorChanged,
    required TResult Function() operatorCleared,
    required TResult Function(int orderId) startOrder,
    required TResult Function(int orderId) endOrder,
    required TResult Function(int orderId) cancelOrder,
  }) {
    return statusChanged(status);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initGeolocation,
    TResult? Function()? loadOrders,
    TResult? Function(OrderStatus status)? statusChanged,
    TResult? Function(Operator serviceOperator)? operatorChanged,
    TResult? Function()? operatorCleared,
    TResult? Function(int orderId)? startOrder,
    TResult? Function(int orderId)? endOrder,
    TResult? Function(int orderId)? cancelOrder,
  }) {
    return statusChanged?.call(status);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initGeolocation,
    TResult Function()? loadOrders,
    TResult Function(OrderStatus status)? statusChanged,
    TResult Function(Operator serviceOperator)? operatorChanged,
    TResult Function()? operatorCleared,
    TResult Function(int orderId)? startOrder,
    TResult Function(int orderId)? endOrder,
    TResult Function(int orderId)? cancelOrder,
    required TResult orElse(),
  }) {
    if (statusChanged != null) {
      return statusChanged(status);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitGeolocation value) initGeolocation,
    required TResult Function(LoadOrders value) loadOrders,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(OperatorChanged value) operatorChanged,
    required TResult Function(OperatorCleared value) operatorCleared,
    required TResult Function(StartOrder value) startOrder,
    required TResult Function(EndOrder value) endOrder,
    required TResult Function(CancelOrder value) cancelOrder,
  }) {
    return statusChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitGeolocation value)? initGeolocation,
    TResult? Function(LoadOrders value)? loadOrders,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(OperatorChanged value)? operatorChanged,
    TResult? Function(OperatorCleared value)? operatorCleared,
    TResult? Function(StartOrder value)? startOrder,
    TResult? Function(EndOrder value)? endOrder,
    TResult? Function(CancelOrder value)? cancelOrder,
  }) {
    return statusChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitGeolocation value)? initGeolocation,
    TResult Function(LoadOrders value)? loadOrders,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(OperatorChanged value)? operatorChanged,
    TResult Function(OperatorCleared value)? operatorCleared,
    TResult Function(StartOrder value)? startOrder,
    TResult Function(EndOrder value)? endOrder,
    TResult Function(CancelOrder value)? cancelOrder,
    required TResult orElse(),
  }) {
    if (statusChanged != null) {
      return statusChanged(this);
    }
    return orElse();
  }
}

abstract class StatusChanged implements OrderEvent {
  const factory StatusChanged(final OrderStatus status) = _$StatusChanged;

  OrderStatus get status;
  @JsonKey(ignore: true)
  _$$StatusChangedCopyWith<_$StatusChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OperatorChangedCopyWith<$Res> {
  factory _$$OperatorChangedCopyWith(
          _$OperatorChanged value, $Res Function(_$OperatorChanged) then) =
      __$$OperatorChangedCopyWithImpl<$Res>;
  @useResult
  $Res call({Operator serviceOperator});

  $OperatorCopyWith<$Res> get serviceOperator;
}

/// @nodoc
class __$$OperatorChangedCopyWithImpl<$Res>
    extends _$OrderEventCopyWithImpl<$Res, _$OperatorChanged>
    implements _$$OperatorChangedCopyWith<$Res> {
  __$$OperatorChangedCopyWithImpl(
      _$OperatorChanged _value, $Res Function(_$OperatorChanged) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? serviceOperator = null,
  }) {
    return _then(_$OperatorChanged(
      null == serviceOperator
          ? _value.serviceOperator
          : serviceOperator // ignore: cast_nullable_to_non_nullable
              as Operator,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $OperatorCopyWith<$Res> get serviceOperator {
    return $OperatorCopyWith<$Res>(_value.serviceOperator, (value) {
      return _then(_value.copyWith(serviceOperator: value));
    });
  }
}

/// @nodoc

class _$OperatorChanged implements OperatorChanged {
  const _$OperatorChanged(this.serviceOperator);

  @override
  final Operator serviceOperator;

  @override
  String toString() {
    return 'OrderEvent.operatorChanged(serviceOperator: $serviceOperator)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OperatorChanged &&
            (identical(other.serviceOperator, serviceOperator) ||
                other.serviceOperator == serviceOperator));
  }

  @override
  int get hashCode => Object.hash(runtimeType, serviceOperator);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OperatorChangedCopyWith<_$OperatorChanged> get copyWith =>
      __$$OperatorChangedCopyWithImpl<_$OperatorChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initGeolocation,
    required TResult Function() loadOrders,
    required TResult Function(OrderStatus status) statusChanged,
    required TResult Function(Operator serviceOperator) operatorChanged,
    required TResult Function() operatorCleared,
    required TResult Function(int orderId) startOrder,
    required TResult Function(int orderId) endOrder,
    required TResult Function(int orderId) cancelOrder,
  }) {
    return operatorChanged(serviceOperator);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initGeolocation,
    TResult? Function()? loadOrders,
    TResult? Function(OrderStatus status)? statusChanged,
    TResult? Function(Operator serviceOperator)? operatorChanged,
    TResult? Function()? operatorCleared,
    TResult? Function(int orderId)? startOrder,
    TResult? Function(int orderId)? endOrder,
    TResult? Function(int orderId)? cancelOrder,
  }) {
    return operatorChanged?.call(serviceOperator);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initGeolocation,
    TResult Function()? loadOrders,
    TResult Function(OrderStatus status)? statusChanged,
    TResult Function(Operator serviceOperator)? operatorChanged,
    TResult Function()? operatorCleared,
    TResult Function(int orderId)? startOrder,
    TResult Function(int orderId)? endOrder,
    TResult Function(int orderId)? cancelOrder,
    required TResult orElse(),
  }) {
    if (operatorChanged != null) {
      return operatorChanged(serviceOperator);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitGeolocation value) initGeolocation,
    required TResult Function(LoadOrders value) loadOrders,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(OperatorChanged value) operatorChanged,
    required TResult Function(OperatorCleared value) operatorCleared,
    required TResult Function(StartOrder value) startOrder,
    required TResult Function(EndOrder value) endOrder,
    required TResult Function(CancelOrder value) cancelOrder,
  }) {
    return operatorChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitGeolocation value)? initGeolocation,
    TResult? Function(LoadOrders value)? loadOrders,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(OperatorChanged value)? operatorChanged,
    TResult? Function(OperatorCleared value)? operatorCleared,
    TResult? Function(StartOrder value)? startOrder,
    TResult? Function(EndOrder value)? endOrder,
    TResult? Function(CancelOrder value)? cancelOrder,
  }) {
    return operatorChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitGeolocation value)? initGeolocation,
    TResult Function(LoadOrders value)? loadOrders,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(OperatorChanged value)? operatorChanged,
    TResult Function(OperatorCleared value)? operatorCleared,
    TResult Function(StartOrder value)? startOrder,
    TResult Function(EndOrder value)? endOrder,
    TResult Function(CancelOrder value)? cancelOrder,
    required TResult orElse(),
  }) {
    if (operatorChanged != null) {
      return operatorChanged(this);
    }
    return orElse();
  }
}

abstract class OperatorChanged implements OrderEvent {
  const factory OperatorChanged(final Operator serviceOperator) =
      _$OperatorChanged;

  Operator get serviceOperator;
  @JsonKey(ignore: true)
  _$$OperatorChangedCopyWith<_$OperatorChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OperatorClearedCopyWith<$Res> {
  factory _$$OperatorClearedCopyWith(
          _$OperatorCleared value, $Res Function(_$OperatorCleared) then) =
      __$$OperatorClearedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OperatorClearedCopyWithImpl<$Res>
    extends _$OrderEventCopyWithImpl<$Res, _$OperatorCleared>
    implements _$$OperatorClearedCopyWith<$Res> {
  __$$OperatorClearedCopyWithImpl(
      _$OperatorCleared _value, $Res Function(_$OperatorCleared) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OperatorCleared implements OperatorCleared {
  const _$OperatorCleared();

  @override
  String toString() {
    return 'OrderEvent.operatorCleared()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OperatorCleared);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initGeolocation,
    required TResult Function() loadOrders,
    required TResult Function(OrderStatus status) statusChanged,
    required TResult Function(Operator serviceOperator) operatorChanged,
    required TResult Function() operatorCleared,
    required TResult Function(int orderId) startOrder,
    required TResult Function(int orderId) endOrder,
    required TResult Function(int orderId) cancelOrder,
  }) {
    return operatorCleared();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initGeolocation,
    TResult? Function()? loadOrders,
    TResult? Function(OrderStatus status)? statusChanged,
    TResult? Function(Operator serviceOperator)? operatorChanged,
    TResult? Function()? operatorCleared,
    TResult? Function(int orderId)? startOrder,
    TResult? Function(int orderId)? endOrder,
    TResult? Function(int orderId)? cancelOrder,
  }) {
    return operatorCleared?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initGeolocation,
    TResult Function()? loadOrders,
    TResult Function(OrderStatus status)? statusChanged,
    TResult Function(Operator serviceOperator)? operatorChanged,
    TResult Function()? operatorCleared,
    TResult Function(int orderId)? startOrder,
    TResult Function(int orderId)? endOrder,
    TResult Function(int orderId)? cancelOrder,
    required TResult orElse(),
  }) {
    if (operatorCleared != null) {
      return operatorCleared();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitGeolocation value) initGeolocation,
    required TResult Function(LoadOrders value) loadOrders,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(OperatorChanged value) operatorChanged,
    required TResult Function(OperatorCleared value) operatorCleared,
    required TResult Function(StartOrder value) startOrder,
    required TResult Function(EndOrder value) endOrder,
    required TResult Function(CancelOrder value) cancelOrder,
  }) {
    return operatorCleared(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitGeolocation value)? initGeolocation,
    TResult? Function(LoadOrders value)? loadOrders,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(OperatorChanged value)? operatorChanged,
    TResult? Function(OperatorCleared value)? operatorCleared,
    TResult? Function(StartOrder value)? startOrder,
    TResult? Function(EndOrder value)? endOrder,
    TResult? Function(CancelOrder value)? cancelOrder,
  }) {
    return operatorCleared?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitGeolocation value)? initGeolocation,
    TResult Function(LoadOrders value)? loadOrders,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(OperatorChanged value)? operatorChanged,
    TResult Function(OperatorCleared value)? operatorCleared,
    TResult Function(StartOrder value)? startOrder,
    TResult Function(EndOrder value)? endOrder,
    TResult Function(CancelOrder value)? cancelOrder,
    required TResult orElse(),
  }) {
    if (operatorCleared != null) {
      return operatorCleared(this);
    }
    return orElse();
  }
}

abstract class OperatorCleared implements OrderEvent {
  const factory OperatorCleared() = _$OperatorCleared;
}

/// @nodoc
abstract class _$$StartOrderCopyWith<$Res> {
  factory _$$StartOrderCopyWith(
          _$StartOrder value, $Res Function(_$StartOrder) then) =
      __$$StartOrderCopyWithImpl<$Res>;
  @useResult
  $Res call({int orderId});
}

/// @nodoc
class __$$StartOrderCopyWithImpl<$Res>
    extends _$OrderEventCopyWithImpl<$Res, _$StartOrder>
    implements _$$StartOrderCopyWith<$Res> {
  __$$StartOrderCopyWithImpl(
      _$StartOrder _value, $Res Function(_$StartOrder) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? orderId = null,
  }) {
    return _then(_$StartOrder(
      null == orderId
          ? _value.orderId
          : orderId // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$StartOrder implements StartOrder {
  const _$StartOrder(this.orderId);

  @override
  final int orderId;

  @override
  String toString() {
    return 'OrderEvent.startOrder(orderId: $orderId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StartOrder &&
            (identical(other.orderId, orderId) || other.orderId == orderId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, orderId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StartOrderCopyWith<_$StartOrder> get copyWith =>
      __$$StartOrderCopyWithImpl<_$StartOrder>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initGeolocation,
    required TResult Function() loadOrders,
    required TResult Function(OrderStatus status) statusChanged,
    required TResult Function(Operator serviceOperator) operatorChanged,
    required TResult Function() operatorCleared,
    required TResult Function(int orderId) startOrder,
    required TResult Function(int orderId) endOrder,
    required TResult Function(int orderId) cancelOrder,
  }) {
    return startOrder(orderId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initGeolocation,
    TResult? Function()? loadOrders,
    TResult? Function(OrderStatus status)? statusChanged,
    TResult? Function(Operator serviceOperator)? operatorChanged,
    TResult? Function()? operatorCleared,
    TResult? Function(int orderId)? startOrder,
    TResult? Function(int orderId)? endOrder,
    TResult? Function(int orderId)? cancelOrder,
  }) {
    return startOrder?.call(orderId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initGeolocation,
    TResult Function()? loadOrders,
    TResult Function(OrderStatus status)? statusChanged,
    TResult Function(Operator serviceOperator)? operatorChanged,
    TResult Function()? operatorCleared,
    TResult Function(int orderId)? startOrder,
    TResult Function(int orderId)? endOrder,
    TResult Function(int orderId)? cancelOrder,
    required TResult orElse(),
  }) {
    if (startOrder != null) {
      return startOrder(orderId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitGeolocation value) initGeolocation,
    required TResult Function(LoadOrders value) loadOrders,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(OperatorChanged value) operatorChanged,
    required TResult Function(OperatorCleared value) operatorCleared,
    required TResult Function(StartOrder value) startOrder,
    required TResult Function(EndOrder value) endOrder,
    required TResult Function(CancelOrder value) cancelOrder,
  }) {
    return startOrder(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitGeolocation value)? initGeolocation,
    TResult? Function(LoadOrders value)? loadOrders,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(OperatorChanged value)? operatorChanged,
    TResult? Function(OperatorCleared value)? operatorCleared,
    TResult? Function(StartOrder value)? startOrder,
    TResult? Function(EndOrder value)? endOrder,
    TResult? Function(CancelOrder value)? cancelOrder,
  }) {
    return startOrder?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitGeolocation value)? initGeolocation,
    TResult Function(LoadOrders value)? loadOrders,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(OperatorChanged value)? operatorChanged,
    TResult Function(OperatorCleared value)? operatorCleared,
    TResult Function(StartOrder value)? startOrder,
    TResult Function(EndOrder value)? endOrder,
    TResult Function(CancelOrder value)? cancelOrder,
    required TResult orElse(),
  }) {
    if (startOrder != null) {
      return startOrder(this);
    }
    return orElse();
  }
}

abstract class StartOrder implements OrderEvent {
  const factory StartOrder(final int orderId) = _$StartOrder;

  int get orderId;
  @JsonKey(ignore: true)
  _$$StartOrderCopyWith<_$StartOrder> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EndOrderCopyWith<$Res> {
  factory _$$EndOrderCopyWith(
          _$EndOrder value, $Res Function(_$EndOrder) then) =
      __$$EndOrderCopyWithImpl<$Res>;
  @useResult
  $Res call({int orderId});
}

/// @nodoc
class __$$EndOrderCopyWithImpl<$Res>
    extends _$OrderEventCopyWithImpl<$Res, _$EndOrder>
    implements _$$EndOrderCopyWith<$Res> {
  __$$EndOrderCopyWithImpl(_$EndOrder _value, $Res Function(_$EndOrder) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? orderId = null,
  }) {
    return _then(_$EndOrder(
      null == orderId
          ? _value.orderId
          : orderId // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$EndOrder implements EndOrder {
  const _$EndOrder(this.orderId);

  @override
  final int orderId;

  @override
  String toString() {
    return 'OrderEvent.endOrder(orderId: $orderId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EndOrder &&
            (identical(other.orderId, orderId) || other.orderId == orderId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, orderId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EndOrderCopyWith<_$EndOrder> get copyWith =>
      __$$EndOrderCopyWithImpl<_$EndOrder>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initGeolocation,
    required TResult Function() loadOrders,
    required TResult Function(OrderStatus status) statusChanged,
    required TResult Function(Operator serviceOperator) operatorChanged,
    required TResult Function() operatorCleared,
    required TResult Function(int orderId) startOrder,
    required TResult Function(int orderId) endOrder,
    required TResult Function(int orderId) cancelOrder,
  }) {
    return endOrder(orderId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initGeolocation,
    TResult? Function()? loadOrders,
    TResult? Function(OrderStatus status)? statusChanged,
    TResult? Function(Operator serviceOperator)? operatorChanged,
    TResult? Function()? operatorCleared,
    TResult? Function(int orderId)? startOrder,
    TResult? Function(int orderId)? endOrder,
    TResult? Function(int orderId)? cancelOrder,
  }) {
    return endOrder?.call(orderId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initGeolocation,
    TResult Function()? loadOrders,
    TResult Function(OrderStatus status)? statusChanged,
    TResult Function(Operator serviceOperator)? operatorChanged,
    TResult Function()? operatorCleared,
    TResult Function(int orderId)? startOrder,
    TResult Function(int orderId)? endOrder,
    TResult Function(int orderId)? cancelOrder,
    required TResult orElse(),
  }) {
    if (endOrder != null) {
      return endOrder(orderId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitGeolocation value) initGeolocation,
    required TResult Function(LoadOrders value) loadOrders,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(OperatorChanged value) operatorChanged,
    required TResult Function(OperatorCleared value) operatorCleared,
    required TResult Function(StartOrder value) startOrder,
    required TResult Function(EndOrder value) endOrder,
    required TResult Function(CancelOrder value) cancelOrder,
  }) {
    return endOrder(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitGeolocation value)? initGeolocation,
    TResult? Function(LoadOrders value)? loadOrders,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(OperatorChanged value)? operatorChanged,
    TResult? Function(OperatorCleared value)? operatorCleared,
    TResult? Function(StartOrder value)? startOrder,
    TResult? Function(EndOrder value)? endOrder,
    TResult? Function(CancelOrder value)? cancelOrder,
  }) {
    return endOrder?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitGeolocation value)? initGeolocation,
    TResult Function(LoadOrders value)? loadOrders,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(OperatorChanged value)? operatorChanged,
    TResult Function(OperatorCleared value)? operatorCleared,
    TResult Function(StartOrder value)? startOrder,
    TResult Function(EndOrder value)? endOrder,
    TResult Function(CancelOrder value)? cancelOrder,
    required TResult orElse(),
  }) {
    if (endOrder != null) {
      return endOrder(this);
    }
    return orElse();
  }
}

abstract class EndOrder implements OrderEvent {
  const factory EndOrder(final int orderId) = _$EndOrder;

  int get orderId;
  @JsonKey(ignore: true)
  _$$EndOrderCopyWith<_$EndOrder> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CancelOrderCopyWith<$Res> {
  factory _$$CancelOrderCopyWith(
          _$CancelOrder value, $Res Function(_$CancelOrder) then) =
      __$$CancelOrderCopyWithImpl<$Res>;
  @useResult
  $Res call({int orderId});
}

/// @nodoc
class __$$CancelOrderCopyWithImpl<$Res>
    extends _$OrderEventCopyWithImpl<$Res, _$CancelOrder>
    implements _$$CancelOrderCopyWith<$Res> {
  __$$CancelOrderCopyWithImpl(
      _$CancelOrder _value, $Res Function(_$CancelOrder) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? orderId = null,
  }) {
    return _then(_$CancelOrder(
      null == orderId
          ? _value.orderId
          : orderId // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$CancelOrder implements CancelOrder {
  const _$CancelOrder(this.orderId);

  @override
  final int orderId;

  @override
  String toString() {
    return 'OrderEvent.cancelOrder(orderId: $orderId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CancelOrder &&
            (identical(other.orderId, orderId) || other.orderId == orderId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, orderId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CancelOrderCopyWith<_$CancelOrder> get copyWith =>
      __$$CancelOrderCopyWithImpl<_$CancelOrder>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initGeolocation,
    required TResult Function() loadOrders,
    required TResult Function(OrderStatus status) statusChanged,
    required TResult Function(Operator serviceOperator) operatorChanged,
    required TResult Function() operatorCleared,
    required TResult Function(int orderId) startOrder,
    required TResult Function(int orderId) endOrder,
    required TResult Function(int orderId) cancelOrder,
  }) {
    return cancelOrder(orderId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initGeolocation,
    TResult? Function()? loadOrders,
    TResult? Function(OrderStatus status)? statusChanged,
    TResult? Function(Operator serviceOperator)? operatorChanged,
    TResult? Function()? operatorCleared,
    TResult? Function(int orderId)? startOrder,
    TResult? Function(int orderId)? endOrder,
    TResult? Function(int orderId)? cancelOrder,
  }) {
    return cancelOrder?.call(orderId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initGeolocation,
    TResult Function()? loadOrders,
    TResult Function(OrderStatus status)? statusChanged,
    TResult Function(Operator serviceOperator)? operatorChanged,
    TResult Function()? operatorCleared,
    TResult Function(int orderId)? startOrder,
    TResult Function(int orderId)? endOrder,
    TResult Function(int orderId)? cancelOrder,
    required TResult orElse(),
  }) {
    if (cancelOrder != null) {
      return cancelOrder(orderId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitGeolocation value) initGeolocation,
    required TResult Function(LoadOrders value) loadOrders,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(OperatorChanged value) operatorChanged,
    required TResult Function(OperatorCleared value) operatorCleared,
    required TResult Function(StartOrder value) startOrder,
    required TResult Function(EndOrder value) endOrder,
    required TResult Function(CancelOrder value) cancelOrder,
  }) {
    return cancelOrder(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitGeolocation value)? initGeolocation,
    TResult? Function(LoadOrders value)? loadOrders,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(OperatorChanged value)? operatorChanged,
    TResult? Function(OperatorCleared value)? operatorCleared,
    TResult? Function(StartOrder value)? startOrder,
    TResult? Function(EndOrder value)? endOrder,
    TResult? Function(CancelOrder value)? cancelOrder,
  }) {
    return cancelOrder?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitGeolocation value)? initGeolocation,
    TResult Function(LoadOrders value)? loadOrders,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(OperatorChanged value)? operatorChanged,
    TResult Function(OperatorCleared value)? operatorCleared,
    TResult Function(StartOrder value)? startOrder,
    TResult Function(EndOrder value)? endOrder,
    TResult Function(CancelOrder value)? cancelOrder,
    required TResult orElse(),
  }) {
    if (cancelOrder != null) {
      return cancelOrder(this);
    }
    return orElse();
  }
}

abstract class CancelOrder implements OrderEvent {
  const factory CancelOrder(final int orderId) = _$CancelOrder;

  int get orderId;
  @JsonKey(ignore: true)
  _$$CancelOrderCopyWith<_$CancelOrder> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$OrderState {
  bool get isLoading => throw _privateConstructorUsedError;
  OrderStatus get status => throw _privateConstructorUsedError;
  Operator get serviceOperator => throw _privateConstructorUsedError;
  Option<Either<Failure, List<Order>>> get orders =>
      throw _privateConstructorUsedError;
  Option<Either<Failure, List<Client>>> get clients =>
      throw _privateConstructorUsedError;
  Option<Either<Failure, List<Operator>>> get operators =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $OrderStateCopyWith<OrderState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrderStateCopyWith<$Res> {
  factory $OrderStateCopyWith(
          OrderState value, $Res Function(OrderState) then) =
      _$OrderStateCopyWithImpl<$Res, OrderState>;
  @useResult
  $Res call(
      {bool isLoading,
      OrderStatus status,
      Operator serviceOperator,
      Option<Either<Failure, List<Order>>> orders,
      Option<Either<Failure, List<Client>>> clients,
      Option<Either<Failure, List<Operator>>> operators});

  $OperatorCopyWith<$Res> get serviceOperator;
}

/// @nodoc
class _$OrderStateCopyWithImpl<$Res, $Val extends OrderState>
    implements $OrderStateCopyWith<$Res> {
  _$OrderStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? status = null,
    Object? serviceOperator = null,
    Object? orders = null,
    Object? clients = null,
    Object? operators = null,
  }) {
    return _then(_value.copyWith(
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as OrderStatus,
      serviceOperator: null == serviceOperator
          ? _value.serviceOperator
          : serviceOperator // ignore: cast_nullable_to_non_nullable
              as Operator,
      orders: null == orders
          ? _value.orders
          : orders // ignore: cast_nullable_to_non_nullable
              as Option<Either<Failure, List<Order>>>,
      clients: null == clients
          ? _value.clients
          : clients // ignore: cast_nullable_to_non_nullable
              as Option<Either<Failure, List<Client>>>,
      operators: null == operators
          ? _value.operators
          : operators // ignore: cast_nullable_to_non_nullable
              as Option<Either<Failure, List<Operator>>>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $OperatorCopyWith<$Res> get serviceOperator {
    return $OperatorCopyWith<$Res>(_value.serviceOperator, (value) {
      return _then(_value.copyWith(serviceOperator: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_OrderStateCopyWith<$Res>
    implements $OrderStateCopyWith<$Res> {
  factory _$$_OrderStateCopyWith(
          _$_OrderState value, $Res Function(_$_OrderState) then) =
      __$$_OrderStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isLoading,
      OrderStatus status,
      Operator serviceOperator,
      Option<Either<Failure, List<Order>>> orders,
      Option<Either<Failure, List<Client>>> clients,
      Option<Either<Failure, List<Operator>>> operators});

  @override
  $OperatorCopyWith<$Res> get serviceOperator;
}

/// @nodoc
class __$$_OrderStateCopyWithImpl<$Res>
    extends _$OrderStateCopyWithImpl<$Res, _$_OrderState>
    implements _$$_OrderStateCopyWith<$Res> {
  __$$_OrderStateCopyWithImpl(
      _$_OrderState _value, $Res Function(_$_OrderState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? status = null,
    Object? serviceOperator = null,
    Object? orders = null,
    Object? clients = null,
    Object? operators = null,
  }) {
    return _then(_$_OrderState(
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as OrderStatus,
      serviceOperator: null == serviceOperator
          ? _value.serviceOperator
          : serviceOperator // ignore: cast_nullable_to_non_nullable
              as Operator,
      orders: null == orders
          ? _value.orders
          : orders // ignore: cast_nullable_to_non_nullable
              as Option<Either<Failure, List<Order>>>,
      clients: null == clients
          ? _value.clients
          : clients // ignore: cast_nullable_to_non_nullable
              as Option<Either<Failure, List<Client>>>,
      operators: null == operators
          ? _value.operators
          : operators // ignore: cast_nullable_to_non_nullable
              as Option<Either<Failure, List<Operator>>>,
    ));
  }
}

/// @nodoc

class _$_OrderState implements _OrderState {
  const _$_OrderState(
      {required this.isLoading,
      required this.status,
      required this.serviceOperator,
      required this.orders,
      required this.clients,
      required this.operators});

  @override
  final bool isLoading;
  @override
  final OrderStatus status;
  @override
  final Operator serviceOperator;
  @override
  final Option<Either<Failure, List<Order>>> orders;
  @override
  final Option<Either<Failure, List<Client>>> clients;
  @override
  final Option<Either<Failure, List<Operator>>> operators;

  @override
  String toString() {
    return 'OrderState(isLoading: $isLoading, status: $status, serviceOperator: $serviceOperator, orders: $orders, clients: $clients, operators: $operators)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_OrderState &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.serviceOperator, serviceOperator) ||
                other.serviceOperator == serviceOperator) &&
            (identical(other.orders, orders) || other.orders == orders) &&
            (identical(other.clients, clients) || other.clients == clients) &&
            (identical(other.operators, operators) ||
                other.operators == operators));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isLoading, status,
      serviceOperator, orders, clients, operators);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OrderStateCopyWith<_$_OrderState> get copyWith =>
      __$$_OrderStateCopyWithImpl<_$_OrderState>(this, _$identity);
}

abstract class _OrderState implements OrderState {
  const factory _OrderState(
          {required final bool isLoading,
          required final OrderStatus status,
          required final Operator serviceOperator,
          required final Option<Either<Failure, List<Order>>> orders,
          required final Option<Either<Failure, List<Client>>> clients,
          required final Option<Either<Failure, List<Operator>>> operators}) =
      _$_OrderState;

  @override
  bool get isLoading;
  @override
  OrderStatus get status;
  @override
  Operator get serviceOperator;
  @override
  Option<Either<Failure, List<Order>>> get orders;
  @override
  Option<Either<Failure, List<Client>>> get clients;
  @override
  Option<Either<Failure, List<Operator>>> get operators;
  @override
  @JsonKey(ignore: true)
  _$$_OrderStateCopyWith<_$_OrderState> get copyWith =>
      throw _privateConstructorUsedError;
}
